package team003.controller;

import team003.util.RobotFilter;
import team003.util.RobotFilter.lowFlux;
import team003.util.RobotFilter.is;
import team003.util.Timer;
import team003.util.Youtil;
import team003.actions.Mover;
import team003.actions.Spawner;
import team003.battlegroups.APlusGroup;
import team003.battlegroups.BattleGroup;
import team003.battlegroups.DefensiveGroup;
import team003.battlegroups.OffensiveGroup;
import battlecode.common.Clock;
import battlecode.common.Direction;
import battlecode.common.GameActionException;
import battlecode.common.GameObject;
import battlecode.common.MapLocation;
import battlecode.common.Robot;
import battlecode.common.RobotController;
import battlecode.common.RobotLevel;
import battlecode.common.RobotType;

public class Archon extends Brain {

  private final Spawner spawner;
  private final BattleGroup battleGroup;
  private final DefensiveGroup defensiveGroup;
  private final BattleGroup offensiveGroup;

  private int myArchonID;

  private Timer groupMove = new Timer();
  private Timer explore = new Timer();
  private boolean startedToBuild = false;
  
  //these fields used in InitialSpread
  private static final int maxBackAndForth = 2;
  private int numBackAndForth;
  private MapLocation lastLocation;
  private MapLocation currentLocation;

  // PARAMETERS FOR DECISIONS
  static final float fluxSustainThreshold = 15; // 15
  static final float desiredFluxDonation = 30;
  //static final float fluxSpawnThreshold = 25;
  static final int enemyTooClose = 99;

  public Archon(RobotController rc) {
    super(rc);
    spawner = new Spawner(rc, sensor, pathfinder);
    archonTooClose = 4;
    bgTooClose = 6;
    battleGroup = new APlusGroup(rc, sensor, outBox);
    defensiveGroup = new DefensiveGroup(rc, sensor, outBox);
    offensiveGroup = new OffensiveGroup(rc, sensor, outBox);
    
    lastLocation = rc.getLocation();
    currentLocation = rc.getLocation();
  }
  
  protected Mover getMover() {return spawner;}

  @Override
  public void takeOneTurn() throws GameActionException {

  	if (Clock.getRoundNum() == 0) {
  		roundOneIdentification();
      if (myArchonID == 0) {
        strategy = Strategy.DEFENSIVE;
        //    strategy = Strategy.BATTLEGROUP;

      } else if (myArchonID > 2){
        // TODO disband if we are attacked before finishing making the group
        // TODO have a way to tell recruits were disbanding.
        strategy = Strategy.BATTLEGROUP;
      } else {
        strategy = Strategy.OFFENSIVEGROUP;
        // strategy = Strategy.OFFENSIVE;
        // strategy = Strategy.BATTLEGROUP;
      }
  	}

    decideStrategy();

    tic("decide strategy");

    switch (strategy) {
    case BATTLEGROUP:
      rc.setIndicatorString(2, "I'm in a battlegroup bitches");
      if (!startedToBuild && initialBGSpread()) { tic("initialBGspread"); return; }
      if (ensureAndFluxFullGroup(battleGroup)) { return; }


      //        if (waitingToBuildTower()) {
      //          actor.tryBuildTower();
      //        } 
      //        if (explore.isNthRound(12)) {
      //          // if ( moveGroupTowardsTower(battleGroup)         ) { rc.setIndicatorString(1, "5: move towards tower"); return; }
      //          if ( moveTowardsTower()         ) { rc.setIndicatorString(1, "5: move towards tower"); return; }
      //          if ( fleeNearbyEnemy()          ) { rc.setIndicatorString(1, "2: fleeing nearby enemy"); return; }
      //          if ( fleeNearbyAlliedArchon(actor, archonTooClose)   ) { rc.setIndicatorString(1, "4: flee nearby allied archon"); return; }
      //        }
      //        

      break;
    case DEFENSIVE:
      rc.setIndicatorString(2, "I'm in defensive mode bitches");
      if (!rc.getLocation().equals(sensor.getClosestAlliedNode().add(Direction.SOUTH))) {
        spawner.moveTo(sensor.getClosestAlliedNode().add(Direction.SOUTH));
      } else {
        ensureAndFluxFullGroup(defensiveGroup);
      }
      break;

    case OFFENSIVEGROUP:
      rc.setIndicatorString(2, "I'm in an offensive battlegroup bitches");
<<<<<<< HEAD
      if (initialOffSpread()) {return;}
      if (waitingToBuildTower()) {rc.setIndicatorString(1, "waiting to build tower"); spawner.tryBuildTower(); return;}
      if (fleeNearbyEnemy(2)   ) {rc.setIndicatorString(1, "fleeing nearby enemy"); return; }
=======
      if (initialOffSpread()) { tic("initial off spread"); return;}
      if (waitingToBuildTower()) {rc.setIndicatorString(1, "waiting to build tower"); spawner.tryBuildTower(); tic("build tower"); return;}
      if ( fleeNearbyEnemy()          ) { rc.setIndicatorString(1, "2: fleeing nearby enemy"); tic("flee nearbyEnemy"); return; }
>>>>>>> 4d54a203966f0326f55395241fd9c6334549b302
      if (explore.isNthRound(5)) {
        //if ( moveGroupTowardsTower(offensiveGroup)         ) { rc.setIndicatorString(1, "5: move towards tower"); return; }
        if ( moveTowardsTower()         ) { rc.setIndicatorString(1, "move towards tower"); return; }
        if ( fleeNearbyAlliedArchon( archonTooClose)   ) { rc.setIndicatorString(1, "flee nearby allied archon"); return; }
        //if (fleeAlliedArchons()) {return;}
      }
      if (ensureAndFluxFullGroup(offensiveGroup)) { rc.setIndicatorString(1, "ensuring and fluxing group"); tic("ensureAndFlux..."); return; }
      
      break;
    case OFFENSIVE:
      rc.setIndicatorString(2, "I'm super offensive independent bitches");
      spawner.tryFluxTransfer(fluxSustainThreshold, desiredFluxDonation);
      if (waitingToBuildTower()) {
        rc.setIndicatorString(1, "waiting to build tower");
        spawner.tryBuildTower();
      } /*else {
        rc.setIndicatorString(1, "spawn units");
        spawnUnits();
      }*/
      if (spawnUnits()) {rc.setIndicatorString(1, "spawn units"); return;}
      if (waitingToBuildTower()) {rc.setIndicatorString(1, "waiting to build tower"); return; }
      if (fleeNearbyEnemy(1)) {rc.setIndicatorString(1, "flee nearby enemy"); return;}
      //if (initialOffSpread()) {return;}
      if (moveTowardsLowFluxUnits()) {rc.setIndicatorString(1, "move toward low flux"); return; }
      if (fleeAlliedArchons()) {rc.setIndicatorString(1, "flee allied archons"); return;}
      if (moveTowardsTower()) {rc.setIndicatorString(1, "move toward tower"); return;}
      
      break;
      /* 
      actor.tryFluxTransfer(minFluxSustain);
      if (waitingToBuildTower()) {
        actor.tryBuildTower();
      } else if (
          RobotFilter.filter(sensor.getNearbyRobots(), new is(RobotType.SCOUT, sensor.myTeam)).length == 0 && sensor.getNearbyEnemies().length == 0)
        actor.trySpawn(RobotType.SCOUT, minFluxSpawn);
      else {
        actor.trySpawnSoldier(minFluxSpawn);
      }
      if ( fleeNearbyEnemy()          ) { rc.setIndicatorString(1, "2: fleeing nearby enemy"); return; }
      //if ( fleeNearbyEnemyToAlliedArchons()          ) { rc.setIndicatorString(1, "2: fleeing nearby enemy"); return; }
      if ( waitingToBuildTower()      ) { rc.setIndicatorString(1, "1: waiting to build tower"); return; }
   //   if ( moveTowardsLowFluxUnits()  ) { rc.setIndicatorString(1, "3: move towards low flux"); return; }
      if ( fleeNearbyAlliedArchon(actor, archonTooClose)   ) { rc.setIndicatorString(1, "4: flee nearby allied archon"); return; }
      if ( moveTowardsTower()         ) { rc.setIndicatorString(1, "5: move towards tower"); return; }
      break;
       */
    default:
      return;
    }
  }

  // all defensive for ben's defensive testing; apologies if I commit this by mistake.
  public void decideStrategy() {
<<<<<<< HEAD
    if (myArchonID == 0) {
      //strategy = Strategy.DEFENSIVE;
      strategy = Strategy.OFFENSIVE;
      //    strategy = Strategy.BATTLEGROUP;

    } else if (myArchonID > 5){
      // TODO disband if we are attacked before finishing making the group
      // TODO have a way to tell recruits were disbanding.
      strategy = Strategy.BATTLEGROUP;
    } else {
      //strategy = Strategy.OFFENSIVEGROUP;
      strategy = Strategy.OFFENSIVE;
      //    strategy = Strategy.BATTLEGROUP;
=======
>>>>>>> 4d54a203966f0326f55395241fd9c6334549b302



    // TODO Set dynamic strat decision
  }



  //BATTLEGROUP Methods:
  public boolean initialBGSpread() throws GameActionException {
    
    if (tooManyBackAndForth()) {
      rc.setIndicatorString(1, "too many back and forth, so starting to build");
      startedToBuild = true;
      return false;
    }
    
   
    //move an archon towards each tower, to get some spread
    final MapLocation[] capturable = rc.senseCapturablePowerNodes();
    for (int i = 0; i < capturable.length; i++) {
      if (myArchonID == 5-i) {
        if (Youtil.manhattanDist(capturable[i], rc.getLocation()) <= 2) {
          rc.setIndicatorString(1, "at node");
          startedToBuild = true;
          return false;
        } else {
        
          rc.setIndicatorString(1, "towards node");
          getMover().moveTo(capturable[i]);
          return true;
        }
      }
    }
    
    if (Clock.getRoundNum() < 17) {
            
      rc.setIndicatorString(1, "spread from point");
      spawner.spreadFromPoint(rc.sensePowerCore().getLocation());
      return true;
    } else if (findSpotToCamp()) {
      return true;
    } else {
      rc.setIndicatorString(1, "start to build");
      startedToBuild = true;
    }
    return false;
  }

  /**
   * counts consecutive back and forths
   */
  private boolean tooManyBackAndForth() {
    if (!rc.getLocation().equals(currentLocation)) {
 
      if (rc.getLocation().equals(lastLocation)) {
        numBackAndForth++;
      } else {
        numBackAndForth = 0;
      }
      
      lastLocation = currentLocation;
      currentLocation = rc.getLocation();
    }
    return numBackAndForth > maxBackAndForth;
  }

  public boolean findSpotToCamp() throws GameActionException {
    if (sensor.alliedArchonsTooClose(bgTooClose) && !startedToBuild) {
      rc.setIndicatorString(1, "allied archons too close");
      spawner.moveVaguely(null, sensor.getAlliedArchonLocations()); //rc.senseCapturablePowerNodes()
      return true;
    }
    if (!battleGroup.roomForGroup() && (sensor.getAdjacentVoids().length > 0)) {
      rc.setIndicatorString(1, "adjacent voids too close");
      spawner.moveVaguely(null, sensor.getAdjacentImpassables());
      return true;
    }
    return false;
  }

  public boolean ensureAndFluxFullGroup(BattleGroup group) throws GameActionException {
    group.update();
    
    tic("group.update");
    
    if (!group.isMobile && !group.inFormation() && groupMove.isNthRound(5)) {
      // this if-statement must go here, not in manageBattleGroup
      
      group.orderToInitialFormation();
      
      tic("group.order to formation");
   
    }
    if (group.typeToSpawn() == null) {
      spawner.tryFluxTransfer(fluxSustainThreshold, desiredFluxDonation);
      return false;
    }
    
    manageBattleGroup(group);
    
    tic("manage battle group");
    return true;
  }

  public void manageBattleGroup(BattleGroup group) throws GameActionException {
    spawner.spawnDefenseBattleGroup(group);
    RobotType type = group.typeToSpawn();
    if (type != null) {
      Robot robot = (Robot) rc.senseObjectAtLocation(sensor.getFrontLocation(), type.level);
      if (robot != null && rc.canSenseObject(robot)) {
        group.registerMember(rc.senseRobotInfo(robot));
      }
    }
<<<<<<< HEAD
    spawner.tryFluxTransfer(fluxSustainThreshold, desiredFluxDonation);
=======
    
    tic("registers");
    spawner.tryFluxTransfer(minFluxSustain);
    
    tic("try flux");
>>>>>>> 4d54a203966f0326f55395241fd9c6334549b302
  }

  //Offensive Methods
  public boolean initialOffSpread() throws GameActionException {
    if (Clock.getRoundNum() < 17) {
      //    if (sensor.alliedArchonsTooClose(archonTooClose)) {
      //actor.spreadFromPoint(rc.sensePowerCore().getLocation());
      spawner.moveVaguely(rc.senseCapturablePowerNodes(), null);
      return true;
    }
    return false;
  }

  private boolean fleeNearbyEnemy(int fearlevel) throws GameActionException {
    //are any enemies too close?
    if (sensor.existNearbyEnemyFighters()) { 
      //RobotFilter.filter(nearbyRobots, new isNot(RobotType.ARCHON, rc.getTeam()));
      // int dist = sensor.myDistanceTo(sensor.getClosestRobot(sensor.getNearbyEnemyFighters()).location);
      //  if (dist <= enemyTooClose) {
      //  return actor.flee(new is(null, sensor.opponentTeam));
      //  }
      //    return actor.fleeFromPoint(sensor.getClosestRobot(sensor.getNearbyEnemyFighters()).location);
      return spawner.spreadFromPoint(sensor.getClosestRobot(sensor.getNearbyEnemyFighters()).location);
    }
    
    if (fearlevel < 1) { return false; }
    
    if (inBox.numEnemyFighters > 0) {
      return spawner.spreadFromPoint(inBox.enemyFighters[Youtil.indexOfMin(rc.getLocation(), inBox.enemyFighters)]);
    }
    
    if (fearlevel < 2) { return false; }
    
    if (inBox.existEnemyMessages) {
      return spawner.spreadFromPoint(sensor.getFrontLocation());
    }
    return false;
  }

  private boolean waitingToBuildTower() throws GameActionException {
    // TODO will still wait to build a tower if enemies are in sight
    if ( sensor.nextToAndFacingTower() ) { // && !enemiesInSight() ) {   
      final GameObject object = rc.senseObjectAtLocation(sensor.getFrontLocation(), RobotType.TOWER.level);
      if (object == null || rc.senseRobotInfo((Robot) object).type != RobotType.TOWER) {
        return true;
      }
    }
    return false;
  }

  private boolean spawnUnits() throws GameActionException {
    //if there is not a scout with you and no enemies are nearby, spawn a scout.
    //otherwise, spawn a soldier
    if (RobotFilter.filter(sensor.getNearbyRobots(), new is(RobotType.SCOUT, sensor.myTeam)).length == 0) {
        //&& sensor.getNearbyEnemies().length == 0) { [cld] took out because logic above should manage this
      //spawner.tryFluxTransfer(fluxSustainThreshold);
      //return spawner.spinOrSpawn(RobotType.SCOUT); [cld] not such a high priority that we need to queue a rotate
      return spawner.trySpawn(RobotType.SCOUT);
    } else {
      //spawner.tryFluxTransfer(fluxSustainThreshold);
      //return spawner.spinOrSpawn(RobotType.SOLDIER);
      return spawner.trySpawn(RobotType.SOLDIER);
    }
  }

  private boolean fleeAlliedArchons() throws GameActionException {
    if (sensor.existNearbyAlliedArchons()) { 
      MapLocation archonLoc = sensor.getClosestRobot(sensor.getNearbyAlliedArchons()).location;
      //if (sensor.myDistanceTo(archonLoc) < archonTooClose)
      if (rc.getLocation().distanceSquaredTo(archonLoc) < archonTooClose*archonTooClose)
        // return actor.fleeFromPoint(archonLoc);
        return spawner.spreadFromPoint(archonLoc);
    }
    return false;
  }

  private boolean moveTowardsTower() throws GameActionException {
    return spawner.moveTo(sensor.getClosestCapturableNode());
  }


  //other methods:
  private boolean fleeNearbyEnemyToAlliedArchons() throws GameActionException {
    //are any enemies too close?
    if (!inBox.existEnemyMessages &&
        !sensor.existRobots(sensor.getNearbyEnemyFighters())) { return false; }
    //RobotFilter.filter(nearbyRobots, new isNot(RobotType.ARCHON, rc.getTeam()));
    //int dist = sensor.myDistanceTo(sensor.getClosestRobot(sensor.getNearbyEnemyFighters()).location);
    //if (inBox.existEnemyMessages || dist <= enemyTooClose) {
    //return actor.moveBackTo(sensor.getClosestAlliedArchon());
    spawner.moveTo(sensor.getClosestAlliedArchon());
    //actor.spreadFromPoint(sensor.getClosestRobot(sensor.getNearbyEnemyFighters()).location);
    return true;
    //}
    // return false;
  }

  private boolean moveGroupTo(BattleGroup group, MapLocation location) throws GameActionException {
    if (!spawner.moveTo(location)) {
      group.orderToLocation(location);
      return false;
    }
    return true;
  }

  private boolean moveGroupTowardsTower(BattleGroup group) throws GameActionException {
    /*if (sensor.nextToAndFacingTower()) {
      //already there!
      return false;
    }*/
    /*if ( groupMove.isNthRound(5)) {
      group.orderToLocation();
    }*/
    if (!spawner.moveTo(sensor.getClosestCapturableNode())) {
      group.orderToLocation(sensor.getClosestCapturableNode());
      return false;
    }
    return true;
  }


  private boolean moveTowardsLowFluxUnits() throws GameActionException {    
    return spawner.chase(new lowFlux(rc.getTeam(), fluxSustainThreshold));
  }


  public void roundOneIdentification() throws GameActionException {
    
      // Assign numbers to archons to use for deciding which archon does what.
      int myID = rc.getRobot().getID();

      int[] theirIDs = new int[6];
      int j = 0;
      for (MapLocation loc : rc.senseAlliedArchons()) {
        theirIDs[j] = rc.senseObjectAtLocation(loc, RobotLevel.ON_GROUND).getID();
        j++;
      }

      java.util.Arrays.sort(theirIDs);

      for (int i = 0; i < 6; i++) {
        if (myID > theirIDs[i]) {
          myArchonID++;
        } else {
          break;
        }
      }
    
  }

  @Override
  protected boolean shouldReceiveMessages() {
    return false;
  }

  @Override
  protected boolean shouldSendMessages() {
    return true;
  }
}
