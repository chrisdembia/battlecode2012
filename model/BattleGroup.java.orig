package team140.model;

import team140.pathfinder.Delta;
import battlecode.common.Direction;
import battlecode.common.GameActionException;
import battlecode.common.MapLocation;
import battlecode.common.RobotController;
import battlecode.common.RobotInfo;
import battlecode.common.RobotType;

public abstract class BattleGroup {

  public final RobotController rc;
  public final Sensor sensor;
  public final OutgoingQueue outBox;

  public final MapLocation[] locations;
  public final RobotInfo[] members;
  public final int rosterLength;
  public final int[] memberIDs;
  
  //these must be assigned in subclass constructor
  public final RobotType[] roster;
  public final Delta[] formation;
  public final Direction[] direction;

  public BattleGroup(RobotController rc, Sensor sensor, OutgoingQueue outBox) {
    this.rc = rc;
    this.sensor = sensor;
    this.outBox = outBox;
    
    this.rosterLength = getRosterLength();
    this.locations = new MapLocation[rosterLength];
    this.members = new RobotInfo[rosterLength];
    this.memberIDs = new int[rosterLength];
    
    this.roster = getRoster();
    this.formation = getFormation();
    this.direction = getDirections();
  }
  
  // these methods are overwritten in subclass
  // if you want to access them externally, just grab the field directly
  protected abstract int getRosterLength();
  protected abstract RobotType[] getRoster();
  protected abstract Delta[] getFormation();
  protected abstract Direction[] getDirections();

  // TODO RESPAWNING, and picking up stragglers to fit in what the group needs

  public boolean registerMember(RobotInfo robot, int id) {
    for (int i = 0; i < rosterLength; i++) {
      if (robot.type.equals(roster[i]) && members[i] == null) {
        members[i] = robot;
        memberIDs[i] = id;
        return true;
      }
    }
    return false;
  }

  public RobotType typeToSpawn() {
    for (int i = 0; i < rosterLength; i++) {

      if (members[i] == null ) {
        return roster[i];
      }
    }
    return null;
  }

  public boolean allAlive() {
    for (int i = 0; i < rosterLength; i++) {
      if (members[i] == null) { return false; }
    }
    return true;
  }

  public void update() throws GameActionException {
    for (int i = 0; i < rosterLength; i++) {
      if (members[i] != null)
        members[i] = rc.senseRobotInfo(members[i].robot);
    }
  }


  /*public boolean setIsAlive() {   

for (int i = 0; i < rosterLength; i++) {

    for (int j = 0; j < sensor.getNearbyRobots().length; j++) {
            if (memberIDs[i] == sensor.getNearbyRobots()[j].robot.getID()) {
                isAlive[i] = true;
                break;
            }

}

members[i] = null;
    }
}*/

  public boolean inFormation() {
    for (int i = 0; i < rosterLength; i++) {
      // return true if all robots are either dead or at the right location
      if (!members[i].location.equals(locations[i])) {return false;}
    }
    return true;
  }

  public boolean orderToLocation() {

    MapLocation ml;
    for (int i = 0; i < rosterLength; i++) {
      ml = Delta2MapLocation(formation[i]);
<<<<<<< HEAD
      if (members[i] != null) {
        outBox.AddLocationAndDirectionCommand(memberIDs[i], ml, direction[i]);
      }
=======
//      if (members[i] != null) {
//        AddLocationAndDirectionCommand(memberIDs[i], ml, direction[i]);
//      }
>>>>>>> 49c454bb4ba5770523fbd8b0cd6f5127939fb836
    }
    return false;
  }

  private MapLocation Delta2MapLocation(Delta delta) {
    return rc.getLocation().add(delta.dx, delta.dy);
  }
}

  /*private void Delta2MapLocation(MapLocation archonLoc) {
// TODO update for a moving battlegroup
    for (int i =0; i < rosterLength; i++) {
        newLocations[i] = archonLoc.add(Delta[i].dx, Delta[i].dy);
    }
}*/
